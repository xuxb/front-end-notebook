---
title: 算法范式 - 分治法
categories: 算法范式
tags: [算法范式]
date: 2021-06-01 16:32:28
---

# 算法范式 - 分治法

### 概念
当求解的问题较复杂或规模较大时，不能立刻得到原问题的解，但这些问题本身具有这样的特点，它可以分解为若干个与原问题性质相类似的子问题，而这些子问题较简单可方便得到它们的解，因此通过合并这些子问题的解就可得到原问题的解。

> 任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。

### 基本步骤
* 分解问题(divide)：把原问题分解为若干个与原问题性质相类似的子问题
* 求解子问题(conquer)：不断分解子问题直到可方便求出子问题的解为止
* 合并子问题的解(combine)：合并子问题的解得到原问题的解

### 使用场景
* 原问题可以分解为若干个与原问题性质相类似的子问题
* 问题的规模缩小到一定程度后可方便求出解
* 子问题的解可以合并得到原问题的解
* 分解出的各个子问题应相互独立，即不包含重叠子问题

### 案例题
* 有序数组查找（二分法）
* 求根号
* 快速排序、归并排序


```js
/**
 * 找到一个数字在指定精度内的平方根
 * 
 * @param num 数字
 * @param pricision 精度
 */

function sqrt(num, pricision) {
  let up = num > 1 ? num : 1;
  let down = 0;
  let n;

  while(true) {
    n = (down + up) / 2;
    if (n * n - num <= pricision && n * n - num >= 0) break;
    if (n * n - num > pricision) up = n;
    if (n * n - num < 0) down = n;
  }

  return n;
}

sqrt(10, 0.001); // 3.162384033203125
```