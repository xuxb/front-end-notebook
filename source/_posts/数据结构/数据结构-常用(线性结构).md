---
title: 常用线性结构
categories: 数据结构
tags: [数据结构]
date: 2020-11-14 15:48:00
---

# 数据结构-常用(线性结构)

数据结构按照逻辑结构来分类，可分为 **线性结构** 和 **非线性结构**

* 线性结构：数组、链表、栈、队列、串等
* 非线性结构：多维数组、树、图等

## 数组（Array）

存储方式：在内存中占用连续完整的存储空间，最基本的存储结构之一
适用场景：适用于读操作多，写操作少

## 链表（Linked List）

存储方式：在内存中占用非连续完整的存储空间，物理上是非连续、非顺序的，最基本的存储结构之一
适用场景：适用于读操作少，写操作多

#### 双向链表（Doubly Linked List）

**双向链表**是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱

## 栈（Stack）

特点：后进先出，有 **入栈（push）** 和 **出栈（pop）** 操作，可用数组或链表实现

## 队列（Queue）

特点：先进先出，有 **入队（push）** 和 **出队（pop）** 操作，可用数组或链表实现

> 双端队列：可以同时重队头或队尾执行 **入队（push）** 和 **出队（pop）** 操作

## 散列表（Hash Table）

散列表也叫哈希表（hash table），这种数据结构提供了**键（Key）**和**值（value）**的映射关系，只要提供 **Key**，便可高效查找出所匹配的 **Value**，时间复杂度**接近**于为 `O(1)`，基于数组实现，查找快速

#### 哈希函数

哈希函数是一种映射关系，根据数据的关键词 **Key** ，通过一定的函数关系，计算出该元素存储位置的函数

> 哈希函数是将字符串或其他类型的 **Key** 转换成数组的下标 **index**

实现方式：
* 直接定址法：取关键字或关键字的某个线性函数值为散列地址，即 H(key) = key 或 H(key) = a*key + b
* 除留余数法：取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址，即 H(key) = key % p, p < m
* 位运算hash: 通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素
* 平方取中法：先计算出关键字值的平方，然后取平方值中间几位作为散列地址
* 数字分析法：当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址
* 随机数法：选择一个随机函数，把关键字的随机函数值作为它的哈希值

#### 哈希冲突

对应不同的关键字可能获得相同的 hash 地址，即 `key1≠key2`，但是 `f(key1)=f(key2)`。这种现象就是冲突，而且这种冲突只能尽可能的减少，不能完全避免。因为哈希函数是从关键字集合和地址集合的映像，通常关键字集合比较大，而地址集合的元素仅为哈希表中的地址值。

##### a. 开放地址法
**开放地址法**是当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表中无待查的关键字，即查找失败


> 当冲突发生时，使用某种探查(亦称探测)技术在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到

##### b. 二次哈希法

再使用一个哈希函数，对产生地址冲突的关键字再次进行哈希计算，获取另一个哈希地址，直到不再产生冲突，这种方法不易产生“二次聚集”，但是增加的计算的时间。

##### c. 链地址法

每个哈希地址对应的一个线性表，将地址相同的记录按序写入链表，这种处理方法如果收到哈希共计，出现大量的哈希冲突，会导致查询的时间复杂度增长，甚至退化为O(n)，为了提高查询效率我们可以使用跳表或者红黑树等结构替换线性表

### 各数据结构时间复杂度比较
| 分类 | 读取 | 更新 | 插入 | 删除 |
| --- | --- | --- | --- | --- |
| 数组 | O(1) | O(1) | O(n) | O(n) |
| 链表 | O(n) | O(1) | O(1) | O(1) |
| 栈 | O(1) | O(1) | O(1) | O(1) |
| 队列 | O(1) | O(1) | O(1) | O(1) |
| 散列表 | O(1) | O(1) | O(1) | O(1) |

