---
title: HTTPS 协议
categories: HTTP
tags: [HTTP]
date: 2021-01-14 15:39:00
---

# HTTPS 协议

### 1、背景介绍

HTTP的请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，容易遭到黑客攻击

HTTP 的主要风险如下：
1. 窃听风险：黑客可以获知通信内容
2. 篡改风险：黑客可以修改通信内容
3. 冒充风险：黑客可以冒充他人身份参与通信

HTTPS：（Secure Hypertext Transfer Protocol）安全超文本传输协议，它基于 HTTP 开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层 (SSL) 进行信息交换。

一句话总结 HTTPS的过程：
HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。

### 2、SSL
SSL (Secure Sockets Layer 安全套接层)，及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS 与 SSL 在传输层对网络连接进行加密。

SSL协议位于 TCP/I P协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

**特点：**
1. 认证用户和服务器，确保数据发送到正确的客户机和服务器；
2. 加密数据以防止数据中途被窃取；
3. 维护数据的完整性，确保数据在传输过程中不被改变。

### 3、加密算法

#### 3.1 对称加密算法

在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。

> 在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密 **密钥** 和 **加密算法**。

特点：加密强度大，难以破解，加密解密速度快

常见的对称加密算法：**AES** 、**RC4** 、**3DES**

#### 3.2 非对称加密算法

非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。

> * 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；
> * 如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密；

特点：性能较低，但是安全性超强

常见的非对称加密算法：**RSA** 、**DSA/DSS**、 **DH** 、、RSA、DSA、ECDSA、 DH

#### 3.3 Hash 算法

说明：将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。

常见的 hash 算法：**MD5**、**SHA-1**、**SHA-2**、**SHA-256**


**结论：** 
**非对称算法** 强度复杂、安全性依赖于算法与密钥但是由于其 **算法复杂**，而使得加密解密速度没有对称加密解密的速度快，公钥加密目前只能用来作 **密钥交换** 或者 **内容签名**，**不适合用来做应用层传输内容的加解密会话密钥客户端在认证完服务器**。获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，和用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，**在数据传输过程中，使用对称加密，可以节省计算资源**。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。


**使用场景：** 
* 甲方生成一对密钥并将其中的公用密钥公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。
* 甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。

### 4、数据加密的方式

##### 方式 1：**使用对称加密**
* 客户端发送给服务器的数据使用 **对称秘钥** 加密，服务器使用 **对称秘钥** 解密
* 服务器发送给客户端的数据使用 **对称秘钥** 加密，客户端使用 **对称秘钥** 解密

缺点：需维护大量的秘钥、秘钥容易泄露

##### 方式 2：**使用非对称加密**
* 客户端发送给服务器的数据使用 **公钥** 加密，服务器使用 **私钥** 解密
* 服务器发送给客户端的数据使用 **私钥** 加密，客户端使用 **公钥** 解密

缺点：公钥是公开的，服务器发送给客户端的数据的数据容易被截获

##### 方式 3：**同时使用对称加密、非对称加密**
* 客户端发送给服务器的 **对称加密算法、对称秘钥** 使用 **公钥** 加密
* 服务器发送给客户端的数据用此 **对称加密算法、对称秘钥** 加密，**对称秘钥** 协商完成
* 客户端发送给服务器的数据使用 **协商的对称秘钥** 加密，服务器使用 **协商的对称秘钥** 解密
* 服务器发送给的客户端数据使用 **协商的对称秘钥** 加密，客户端使用 **协商的对称秘钥** 解密

> 问题：公钥加密（非对称加密）计算量太大，如何减少耗用的时间？
> 解决方法：每一次对话（session），客户端和服务器端都生成一个 **对话密钥**（双方协商的对称秘钥），用它来加密信息。由于 **对话密钥** 是对称加密，所以运算速度非常快，而服务器公钥只用于加密 **对话密钥** 本身，这样就减少了加密运算的消耗时间。

![HTTPS 加密过程](https://www.wosign.cn/Basic/images/howsslwork_clip_image002.gif)

很明显，方式 3 比较合适 HTTP 的数据加密，但依然有 **两个** 问题：
1. 客户端如何获得公钥
2. 如何确认服务器是真实的而不是黑客

> 获取公钥的过程并不能保证安全，似乎又得重新进行一次加密的过程（先有鸡还是先有蛋的问题），So what to do...

### 5、SSL 证书

SSL证书，也称为服务器 SSL 证书，是遵守 SSL 协议的一种数字证书，由全球信任的证书颁发机构 (Certificate Authority，简称 CA) 验证服务器身份后颁发。将SSL证书安装在网站服务器上，可实现网站身份验证和数据加密传输双重功能。

SSL 证书能同时解决了 **公钥获取** 问题和 **黑客冒充** 问题

> 每种支持 HTTPS 的浏览器都内置的许多 CA 中心的公钥信息，CA 中心是浏览器开发商信任的授权机构，它为有需要的网站颁发用于验证的服务器公钥，颁发前 CA 中心应尽量确认申请者的身份，并确保颁发的服务器证书确实是由该域名使用的。<br/>
> 至于CA中心的具体实现上，就是在创建一个新的 HTTPS 连接时，浏览器端收到服务器的签名公钥，验证签名后（除非 CA 的私钥泄漏，否则签名无法被伪造），检查证书里被签名的 cn 项（Common Name，常用名称）或 subjectAltName 项的值，由此确认对方确实是浏览器真正要访问的服务器，并确认该公钥不在 CA 机构的公开撤销列表里（例如，证书是假冒或欺诈手段获取到的）。如果所有检查都通过了，浏览器就可以用这个公钥加密信息并传回给服务器端，通过这种方式，确认只有特定的接收者才能对加密信息进行解密。

SSL 证书是 CA 中心用自己 **私钥** 对申请者的信息进行加密的数据，当用户访问服务器是 SSL 证书从服务器下载到本地，然后浏览器内置了权威的 CA 中心的 **私钥**，用此 **私钥** 解密 SSL 证书中的数据，如果客户端计算出来的证书编号（使用证书中的 **签名算法** 进行计算）与证书中的证书编号相同，则验证通过。


**SSL 证书包含的具体内容如下：**
* Version 版本
* Serial Number序列号
* Algorithm ID 算法标识
* Issuer 颁发者
* Validity 有效期
* Not Before 有效起始日期
* Not After 有效终止日期
* Subject 使用者
* Subject Public Key Info 使用者公钥信息
* Public Key Algorithm公钥算法
* Subject Public Key公钥
* Issuer Unique Identifier (Optional) 颁发者唯一标识（CA 中心）
* Subject Unique Identifier (Optional) 使用者唯一标识
* Extensions (Optional) 扩展
* ...
* Certificate Signature Algorithm 证书签名算法（MD5 算法）
* Certificate Signature 证书签名

**验证步骤：**
1. 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
2. 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发 
3. 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
4. 如果找到，那么浏览器就会从操作系统中取出颁发者 CA  的公钥，然后对服务器发来的证书里面的签名进行解密
5. 浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比
6. 对比结果一致，则证明服务器发来的证书合法，没有被冒充
7. 此时浏览器就可以读取证书中的公钥，用于后续加密了

> 认证信息 ---哈希算法--->  摘要 ---私钥加密---> 数字签名

### 6、HTTPS 的特点

#### HTTPS 优点
1. 所有信息都是加密传播，黑客无法窃听
2. 具有校验机制，一旦被篡改，通信双方会立刻发现
3. 配备身份证书，防止身份被冒充

#### HTTPS 缺点
1. SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐
2. HTTPS 降低用户访问速度（多次握手）
3. 网站改用 HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 302 跳转）
4. HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https 访问过程需要加解密）