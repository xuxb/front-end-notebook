---
title: TCP 与 UDP
categories: HTTP
tags: [HTTP]
date: 2021-01-14 15:32:00
---

#  TCP  与 UDP

当 IP 包通过路由将数据传输到目的地时，会根据 TCP 或 UDP 包头中的源端口和目的端口信息，请求和获取不同的应用。也就是说，不管 TCP 还是 UDP，都含有网络服务必须的源端口和目的端口信息，以建立和实现网络传输服务。

在网络中，有些服务，如 HTTP、FTP 等，对数据的可靠性要求较高，在使用这些服务时，必须保证数据包能够完整无误的送达；而另外一些服务，如 DNS、即时聊天工具等，并不需要这么高的可靠性，高效率和实时性才是它们所关心的。根据这两种服务不同的需求，也就诞生了面向连接的 TCP 协议，以及面向无连接的 UDP 协议。

**怎么理解 TCP 的面向连接和 UDP 的无连接（不面向连接）？**
TCP 关心分组是否准确送达，甚至仔细到给每个分组编号并收到目的端的确认才继续发送后续的分组，而 UDP 则不然，它只负责把分组封装好后直接发送到链路上，至于目的端收到与否并不关心。

> TCP 的面向连接指对话之前需要先建立一个会话，而 UDP 无连接直接发送消息（类似于打电话和写信）

UDP 和 TCP 的特点
* 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
* 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

> TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方

## 一、UDP

UDP（User Data Protocol，用户数据报协议）是一种无连接的协议，提供面向事务的简单不可靠信息传送服务。UDP 协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位，每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。

### 面向报文
UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。

具体来说
* 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
* 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

### 不可靠性
1. UDP 是无连接的，也就是说通信不需要建立和断开连接。
2. UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的
3. UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

### 高效
因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。

![UDP 头信息示意图](https://user-gold-cdn.xitu.io/2018/5/1/163195b245ceb89c?w=831&h=170&f=png&s=22793)

头部包含了以下几个数据
* 两个十六位的端口号，分别为源端口（可选字段）和目标端口
* 整个数据报文的长度
* 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

### 传输方式
UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

### 特点
1.  UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
2.  由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。
3.  UDP 信息包的标题很短，只有8个字节，相对于 TCP 的 20 个字节信息包的额外开销很小。
4.  吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。
5.  UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
6.  UDP 是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

> UDP 主要用在实时性要求高以及对质量相对较弱的地方，如流媒体、实时消息

## 二、TCP
TCP（Transmission Control Protocol，传输控制协议）

TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，即在收发数据前，必须和对方建立可靠的连接。TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接：

### 头部
对于 TCP 头部来说，以下几个字段是很重要的

* Sequence Number，(顺序号码)这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文
* Acknowledgement Number，(确认号码)这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
* Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制
* 标识符
  * URG=1：(urgent 紧急) 该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
  * ACK=1：(acknowledgement 确认)该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。
  * PSH=1：(push 传送)该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
  * RST=1：(reset 重置)该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
  * SYN=1：(synchronous 建立联机) 当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
  * FIN=1：(finish 结束)该字段为一表示此报文段是一个释放连接的请求报文。

![TCP 头部示意图](https://user-gold-cdn.xitu.io/2018/5/1/1631be45b084e4bc?w=858&h=305&f=png&s=62112)


### 状态机
HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态

![TCP 状态机示意图](https://user-gold-cdn.xitu.io/2018/5/1/1631bef9e3c60035?w=1280&h=965&f=png&s=101432)

LISTEN - 侦听来自远方 TCP 端口的连接请求； 
SYN-SENT -在发送连接请求后等待匹配的连接请求； 
SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； 
ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； 
FIN-WAIT-1 - 等待远程 TCP 的连接中断请求，或先前的连接中断请求的确认；
FIN-WAIT-2 - 从远程 TCP 等待连接中断请求； 
CLOSE-WAIT - 等待从本地用户发来的连接中断请求； 
CLOSING -等待远程 TCP 对连接中断的确认； 
LAST-ACK - 等待原来发向远程 TCP 的连接中断请求的确认； 
TIME-WAIT -等待足够的时间以确保远程 TCP 接收到连接中断请求的确认； 
CLOSED - 没有任何连接状态；


### 建立连接（三次握手）
在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。

*   第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机，A进入 SYN_SEND状态，等待主机B确认；
*   第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包，此时主机B进入SYN_RECV状态。；
*   第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

![TCP 三次握手示意图](https://user-gold-cdn.xitu.io/2018/5/1/1631bf1e79b3cd42?w=666&h=426&f=png&s=32121)

> 两支军队，分别由两个将军领导，正在准备攻击一个坚固的城市。两支军队都驻扎在城市旁边的两个不同的山谷里。两军之间隔着第三个山谷，两个将军想要通讯的唯一方法就是穿过第三个山谷传送信件。问题是，第三个山谷被城市的守卫军占据，并且经此传送的信件可能会被守卫军截获。
> * 第一次握手：A蓝数据成功到达B蓝，B蓝收到A蓝的通知“你准备好攻打红色部队了吗？”
> * 第二次握手：B蓝回复A蓝，“我准备好了！”。 假设回复成功到达A蓝，但是此时B蓝并不知道A蓝是否成功收到了它的回复，因此它并不敢轻举妄动，假设A蓝并没有收到回复，没有出兵，那B蓝岂不是会全军覆没。于是很有必要进行第三次握手。
> * 第三次握手：A蓝回复B蓝，“我知道你准备好了，开打吧！” 当B蓝收到这个确认之后，就可以开始出兵了。
>  理论上来说，两军的沟通永远停不下来，因为没有办法确认最后一次数据包是否成功到达对方，所以三次握手也并不是绝对的可靠，可以选择四次，甚至多次握手，但是考虑到开销，选择三次握手，能保证足够的可靠性了。

### 断开连接（四次挥手）

由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

> TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 
3. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 

![TCP 四次挥手示意图](https://user-gold-cdn.xitu.io/2018/5/2/1631fb807f2c6c1b?w=640&h=512&f=png&s=31059)


