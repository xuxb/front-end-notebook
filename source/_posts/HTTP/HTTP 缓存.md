---
title: HTTP 缓存
categories: HTTP
tags: [HTTP]
date: 2021-01-14 15:45:00
---

# HTTP 缓存

## 1、强缓存

说明：强缓存直接从浏览器缓存中获取，不发送请求到服务器 
使用：用`Cache-Control`、 `Expires` 头信息

### 1.1 强缓存相关头信息

* `Cache-Control`: HTTP/1.1 标准， 使用相对时间（从生成文档开始计时，**推荐使用**，优先级高于 `Expires`）
* `Expires`：HTTP/1.0 标准，使用绝对时间（依赖计算器本地时间，可能不准确）

```
// Request Header 
If-None-Match: "2a043f-6741-5456e5e0050c3" 
If-Modified-Since: Fri, 06 Jan 2017 15:06:49 GMT

// Response Header 
Cache-Control: max-age=2592000 
Expires: Sat, 18 Feb 2017 08:31:00 GMT 
ETag: "2a043f-6741-5456e5e0050c3"
Last-Modified: Fri, 06 Jan 2017 15:06:49 GMT
```

### 1.2 Cache-Control 头信息字段

| Cache-directive |	说明 |
| :-: | :-: | 
| private |  **私有缓存**，即内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)，默认为 private |
| public |  **公有缓存**，即所有内容都将被缓存(客户端和代理服务器都可缓存) |
| no-store |  **禁止进行缓存**，即所有内容都不会被缓存到缓存或 Internet 临时文件中 |
| no-cache |  **强制确认缓存**，即必须先与服务器确认返回的响应是否被更改（该请求应该会带有与本地缓存相关的验证字段），然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。 |
| must-revalidation/proxy-revalidation |  **过期校验缓存**，即超过设定的过期时间后会重新检验新鲜度，通常与 *max-age* 配合使用，如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证 |
| immutable |  **不可变的缓存**，即表示该资源是不可变的（如资源名称加了指纹信息，md5 戳等），不用重新验证新鲜度，所以不必向服务器发送请求，直接从缓存中获取，也可设置 max-age 为过期时间 |
| max-age=xxx |  缓存的内容将在 xxx 秒后失效, 这个选项只在 HTTP 1.1可用, 并如果和 Last-Modified 一起使用时, 优先级较高 |
| stale-while-revalidate | 提供的是一个宽限期（由 max-age=xxx ），当检查新版本时，允许浏览器在这段宽限期期间使用过期的（旧的）资源 |
| stale-if-error | 如果重新验证资源时返回了 5xx 之类的错误，stale-if-error 会给浏览器一个使用旧的响应的宽限期 |


> **Clear-Site-Data**：实验性质的响应头，表示清除当前请求网站有关的浏览器数据（cookie，存储，缓存），可选值为 `cache`、`cookies`、`storage` 或 `*`，如登出时可设置响应头为 `Clear-Site-Data: "cache", "cookies", "storage"`

> 通常情况下，因为访问页面的 url 不能改变，所以不对 html 文件作缓存处理，可设置 `Cache-Control: max-age=0`，对于 js、css 等经常改变且含指纹信息的资源，可设置 `Cache-Control: public, max-age=31536000000`


### 1.3 缓存校验
> 用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有 "Cache-control: must-revalidate" 的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced->Cache为强制验证缓存也能达到相同的效果。当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。

> 作为缓存的一种强校验器，ETag 响应头是一个对用户代理(User Agent, 下面简称UA)不透明（译者注：UA 无需理解，只需要按规定使用即可）的值。对于像浏览器这样的HTTP UA，不知道ETag代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。<br/>
> Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。


## 2、协商缓存

说明：先发送请求给服务器，如果命中缓存，则从浏览器缓存中获取 
使用：用 `Last-Modificd` 和 `If-Modificd-Since`、`Etag` 和 `If-None-Match` 头信息

* 分布式系统里多台机器间文件的 last-modified 必须保持一致，以免负载均衡到不同机器导致比对失败
* 分布式系统尽量关闭掉 Etag (每台机器生成的 `Etag` 都会不一样)

Etag: 实体标签（版本标识符），用于表示文档的版本号、序列号、内容校验或指纹信息，表明文档是否被修改

Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间，如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。


### `Etag`、`If-None-Match`

*   Etag：web 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
*   If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。

### `Last-Modified`、`If-Modified-Since`

*   Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉客户端资源的最后修改时间。
*   If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源被改动过，则响应整片资源内容（写在响应消息包体内），则响应HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省流量)，告知浏览器继续使用所保存的cache。


## 3、其他

![HTTP 缓存示意图](http://owl6flhin.bkt.clouddn.com/555379-20160404211645125-1662003962.png)

### 新鲜度

> 理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个If-None-Match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。

![HTTP 新鲜度示意图](https://mdn.mozillademos.org/files/13771/HTTPStaleness.png)

> 对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control: max-age=N的请求头，相应的缓存的寿命就是N。通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的Last-Modified信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）

### 资源加速
> 不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。

> 这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。

### 浏览器缓存

* `200 ok ` : 从原始服务器请求成功
* `200 ok from cache` : 从缓存中获取，未向服务器验证新鲜度
    * `200 ok from disk cache` : 从磁盘中获取（已缓存到磁盘中，如CSS样式等）
    * `200 ok from memory cache` : 从内存中获取（已缓存到磁盘并存在内存中，如脚本、字体、图片等）
* `304 not modified` ：向服务器发送请求，验证新鲜度，足够新鲜，服务器会返回 304状态

### 页面刷新
*   当 F5 刷新页面时，跳过强缓存功能，检查协商缓存（与在地址栏中输入url的作用一样）
*   当 Ctrl + F5 刷新页面时，跳过强缓存和协商缓存 （直接从服务器中加载）