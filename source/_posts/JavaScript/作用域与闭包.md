---
title: 作用域与闭包
categories: JavaScript
tags: [JavaScript 原理]
date: 2021-04-27 17:24:48
---

# 作用域与闭包

### 1、JavaScript 编译

源代码在执行之前会进行编译，分为三个步骤：

1. 分词/词法分析：将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元
2. 解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）
3. 代码生成：将 AST 转换为可执行代码（一组机器指令）

> JavaScript引擎要复杂些，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

* 引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程。
* 编译器：负责语法分析及代码生成等脏活累活（详见前一节的内容）。
* 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

> 以变量赋值为例，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

### 2. 作用域

作用域：是一套规则，用于确定在何处以及如何查找变量（标识符）

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

```js
// 气泡1 （全局环境）
function foo (a) { // 气泡2
    var b = a * 2;

    function bar (c) { // 气泡3
        console.log(a, b, c);
    }
}

foo(2);
```

* 气泡1包含着整个全局作用域，其中只有一个标识符： foo 。
* 气泡2包含着 foo 所创建的作用域，其中有三个标识符： a 、 bar 和 b 。
* 气泡3包含着 bar 所创建的作用域，其中只有一个标识符： c 。

作用域有两种工作模型：词法作用域、动态作用域
> 词法作用域是在定义时确定的，关注函数在何处声明
> 动态作用域是在运行时确定的，关注函数从何处调用，其作用域链是基于运行时的调用栈的。

```js
var a = 2;

function foo() {
  console.log(a);
}

function bar() {
  var a = 3;
  foo();
}

bar();

// 如果js是词法作用域（就是），那么应该会输出 2
// 如果js是动态作用域，那么应该会输出 3
```

### 3、词法作用域

在 JavaScript 中采用词法作用域，即代码在编写过程中体现出来的作用范围，代码一旦写好，不用执行，作用范围就已经确定好了（大部分情况如此，this、with、eval除外）， 这就是所谓的词法作用域。

作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

在多层的嵌套作用域中可以定义同名的标识符，这叫作**遮蔽效应**（内部的标识符遮蔽了外部的标识符）

> 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。

在 JavaScript 中词法作用域规则:
* 函数允许访问函数外的数据
* 整个代码结构中只有函数可以限定作用域（ES6 新增块级作用域）
* 作用规则首先使用提升规则分析
* 通过作用域链进行查找，如果当前作用规则作用域中已查找到，则不再往父作用域查找

### 4、词法欺骗

##### 4.1 eval

JavaScript 中的 `eval()` 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。`eval()` 在运行期修改了书写期的词法作用域。

换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。`eval()` 通过代码欺骗和假装成书写时（也就是词法期），来实现修改词法作用域环境的。

```js
function foo(str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3

// 码实际上在 foo(..) 内部创建了一个变量 b ，并遮蔽了外部（全局）作用域中的同名变量
```

##### 4.2 with

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

```js
function foo(obj) {
    with (obj) {
        a = 2;
    }
}
var o1 = { a: 3 };
var o2 = { b: 3 };
foo( o1 );
console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a );    // 2——不好，a 被泄漏到全局作用域上了！

// o2 的作用域、 foo(..) 的作用域和全局作用域中都没有找到标识符 a ，因此当 a＝2 执行时，
// 自动创建了一个全局变量（因为是非严格模式）。
```

**总结：**
* eval() 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域。
* with 声明实际上是根据传递给它的对象凭空创建了一个全新的词法作用域。   
* 严格模式下，eval() 和 with 功能受限制
* 如果出现了 eval() 或 with ，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。


### 5、函数作用域

函数作用域：指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（包括嵌套的作用域）。

立即执行函数表达式：（Immediately Invoked Function Expression）

```js
var a = 2;
(function IIFE(global, undefined) {
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
})(window);

console.log( a ); // 2

// 将 window 对象的引用传递进去，使得对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰
// 解决 undefined 标识符的默认值被错误覆盖导致的异常
```

### 6、块作用域

块作用域：指变量和函数属于所处的作用域在某个代码块中（通常指 { .. } 内部）

> let 为其声明的变量隐式地创建了块级作用域
> 使用块作用域更加主流，也便于开发、维护


### 7、变量提升

提升：无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端。

* 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地
* 函数声明会被提升，但是函数表达式却不会被提升
* 函数声明和变量声明都会被提升。但函数会首先被提升，然后才是变量
* 在每个作用域中都会被提升，包括全局作用域、函数作用域、块级作用域

以 `var a = 2; `为例，JavaScript 会看做两部分 `var a;` 和 `a = 2;`，第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段。


```js
// 变量声明会被提升
function foo() {
    var a;
    console.log( a ); // undefined
    a = 2;
}
foo();
```

```js
// 函数表达式不会被提升
foo(); // 不是 ReferenceError, 而是 TypeError!
var foo = function bar() {
    console.log(12312);
};
```

```js
foo(); // 1
var foo;
function foo() {
    console.log( 1 );
}
foo = function() {
    console.log( 2 );
};

// ----- output -------
// 输出：1
// ----- javascript 理解成如下形式 -----
// function foo() {
//      console.log( 1 );
// }
// foo(); // 1
// foo = function() {
//      console.log( 2 );
// }; 
```

### 8、闭包

概念：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

作用：
1. 变量和对象的私有化
2. 数据缓存
3. 模块化

```js
function wait(message) {
    setTimeout(function timer() {
        console.log(message);
    }, 1000);
}
wait( "Hello, closure!" );

// 将一个内部函数（名为 timer ）传递给 setTimeout(..) 。
// timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。
// wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失， timer 函数依然保有 wait(..) 作用域的闭包
```

> 在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包

### 9、闭包与循环

```js
for (var i=1; i<=5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i*1000);
}
// outupt ----> 6 6 6 6 6
// 原因：所有的 `i` 被封闭在一个共享的全局作用域中，因此实际上只有一个 `i`
```

```js
for (var i=1; i<=5; i++) {
    (function() {
        setTimeout(function timer() {
            console.log( i );
        }, i*1000);
    })();
}
// outupt ----> 6 6 6 6 6
// 原因：每个函数都是一个作用域，但这个作用域是空的，当查询 `i` 时，依然会从父作用域中查找，实际上是一个 `i`
```

```js
for (var i=1; i<=5; i++) {
    (function() {
        var j = i;
        setTimeout(function timer() {
            console.log( j );
        }, j*1000);
    })();
}

for (var i=1; i<=5; i++) {
    (function(j) {
        setTimeout(function timer() {
            console.log( j );
        }, j*1000);
    })(i);
}
// outupt ----> 1 2 3 4 5
// 原因：IIFE 会为每个迭代都生成一个新的作用域，都有自己的变量，用 `j` 保存 `i` 的值
```

```js
for (var i=1; i<=5; i++) {
    let j = i; // 产生了新的块级作用域！
    setTimeout(function timer() {
        console.log(j);
    }, j*1000);
}

for (let i=1; i<=5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i*1000);
}
// outupt ----> 1 2 3 4 5
// 原因：变量 `i` 是 let 声明的，当前的i只在本轮循环有效，所以每一次循环的 `i` 其实都是一个新的变量, 
//      JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 `i` 时，就在上一轮循环的基础上进行计算
```

```js
// for 循环中 let 还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// ------ output ------
// abc
// abc
// abc

```

### 10、闭包与模块

模块：返回的对象中含有对内部函数而不是内部数据变量的引用，保持内部数据变量是隐藏且私有的状态，并提供公共的API

```js
// 模块模式
function foo() {
    var something = "cool";
    var another = [1, 2, 3];
    function doSomething() {
        console.log(something);
    }
    function doAnother() {
        console.log(another.join( " ! " ));
    }

    return {
        doSomething,
        doAnother
    }
}
```

模块模式的两个必要条件：
1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。