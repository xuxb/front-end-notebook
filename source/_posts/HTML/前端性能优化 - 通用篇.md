---
title: 前端性能优化
categories: 面试题
tags: [面试题]
date: 2021-05-24 16:32:28
---

# 前端性能优化

## 一、代码层面
### 1.1 减少 DOM 元素
DOM 元素越多、越复杂，则 DOM 操作（即重绘、重排）会越慢

优化方式：
* 可以使用伪元素、阴影、CSS 实现的内容尽量不要使用 DOM 实现
* 按需加载，减少不必要的渲染
* 结构合理，语义化标签

### 1.2 降低 CSS 选择器的复杂性
CSS 选择器的匹配规则是是*从右往左*的，即先找到符合条件的元素，然后再匹配父元素进行过滤（why? 符合条件的元素远少于不符合条件的元素，可以节约性能）

所以有如下注意事项：
* 不给ID分类和Class分类添加标签名；（会增加一次过滤）
* 用子代选择器代替后代选择器；（避免无效的遍历）
* 用Class分类代替子代选择器；（避免多次遍历）
* 特殊类别可使用属性选择器；（避免多次遍历）
* 正确使用可继承的属性；（可从父元素传到子元素）
* 尽量避免通配符；（首先会遍历所有的元素，然后再过滤）

### 1.2 尽可能使用 flex 布局
尽量使用 flex 代替浮动、表格等布局，后者会更耗性能且不易维护

### 1.3 使用字体图标代替图片
字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等，而且字体图标是矢量图，不会失真，生成的文件也较小。

### 1.4 合理使用 will-change
告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作

### 1.5 使用 content-visibility
`content-visibility` 属性接受多个值，其中 `auto` 是可立即提高性能的属性。一个具有 `content-visibility: auto` 属性的元素可以获得布局、样式和绘制的限制（区域），如果元素不在屏幕上，这不会渲染其后代。浏览器在不考虑元素任何内容的情况下确定元素的大小，在此处则跳过大多数渲染。

### 1.6 使用 CSS3 GPU 加速

> 在 GPU 渲染的过程中，一些元素会因为符合了某些规则，而被提升为独立的层（黄色边框部分），一旦独立出来，就不会影响其它 DOM 的布局，所以我们可以利用这些规则，将经常变换的 DOM 主动提升到独立的层，那么在浏览器的一帧运行中，就可以减少 Layout 和 Paint 的时间了

CSS 中的以下几个属性能触发硬件加速：
* transform
* opacity
* filter
* will-change

### 1.7 避免过多的回流与重绘
* 重绘（reflow）：重新绘制（如改变某个元素的颜色、背景，并没有使布局改变）
* 重排（repaint）：重新生成布局（如改变某个元素的位置，导致布局改变，同时触发 重排、重绘）

相对于 `Object`、`Array` 操作，DOM 上的操作会慢上几个数量级，即使现代浏览器已经对 DOM 操作（重排、重绘）做了无数优化。所以大部分时候，Web 性能的瓶颈通常在渲染上。


> DOM 操作很慢，绝大部分时候是指 DOM 操作所产生的副作用慢（主要是导致了重排），在页面上的任何操作都是有代价的

说明：
1. 样式表越简单，重排和重绘就越快；
2. 重排和重绘的 DOM 元素层级越高，成本就越高；
3. `<table>` 元素的重排和重绘成本高于 `<div>` 元素

优化方式：
* 批量读写：统一读取属性，然后统一修改 DOM ，减少渲染次数
* 使用 DOM 片段 `document.createDocumentFragment()`
* 多次访问同一 DOM 应用局部变量缓存
* 操作元素时先隐藏，修改完元素后再显示
* 将元素的 `position` 属性为 `absolute` 或 `fixed` 的元素
* 使用 `window.requestAnimationFrame()`、`window.requestIdleCallback()` 调节重新渲染
* 使用虚拟 DOM 技术，如 `React`、`Vue`

### 1.8 使用 preload、prefetch
* `<link rel="preload"></link>`用于本页面要用到的关键资源，包括关键js、字体、css文件。preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度
* `<link rel="prefetch"></link>`用于加速未来页面里的资源，被标记为 prefetch 的资源，将会被浏览器在空闲时间加载，下载顺序权重比较低

### 1.9 使用 requestAnimationFrame 优化动画
使用 `setTimeout` 或 `setInterval` 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，可能经常丢失帧，导致卡顿，requestAnimationFrame 会在浏览器下一次重绘前执行，能使动画看上去更加流畅（PS: 当然最好的方式是使用 CSS3 动画）

### 1.10 使用虚拟列表
虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。详情请看文章末尾的相关链接。

### 1.11 防抖、节流
用于 onresize、onkeydown 等频繁触发的事件中，可减少请求、DOM 操作等，改善用户体验

* 防抖：在多次触发中(还没执行)，只执行最后一个触发。
* 节流：在一段时间内，只能执行一次。

### 1.12 图片优化
* 图片延迟加载：只加载可视区内的图片，根据 `getBoundingClientRect()` 来判断
* 响应式图片：够根据屏幕大小自动加载合适的图片，可通过 `<picture>` 或 `@media` 来实现
* 图片压缩：在可接受的范围内压缩图片，压缩后通常能减少 30% 左右的大小，且肉眼看上去无差异
* 使用 webp 格式的图片：更优的图像数据压缩算法，相比于传统 JPEG、PNG 图片，Webp 可以让图片大小平均减少 70% 左右。
* 合理使用图片、背景图：装饰性的图片应该使用 CSS 的 `background-image` 标签，而不是使用 `img` 标签
  * `img` 标签 DOM 解析完后去加载图片，图片加载失败时会显示一个撕裂的小图标标记，**兼顾 SEO 和标签语义化时应该使用 <img />**
  * `background-image` 内引用的图片会在该规则生效时，才会去下载该图片（有点类似于按需加载），图片加载失败时不会显示异常

### 1.13 使用骨架屏
提前占好位置，当资源加载完成即可填充，减少页面的回流与重绘，同时还能给用户最直接的反馈，主要用于提升用户体验。

### 1.14 预渲染、服务端渲染（SSR）
* 有利于 SEO
* 有利于首屏渲染，提升用户体验

说明：请权衡利弊后，再酌情使用！！

## 二、webpack 相关

### 2.1 Tree Sharking
用于消除无用的 js 代码，ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 Tree Sharking 的基础

### 2.2 代码拆分
使用 webpack 提供的 `optimization.splitChunks` 属性，主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件等。

### 2.3 使用外部扩展 externals
防止将某些 `import` 的包打包到 bundle 中，而是在运行时再去从外部获取这些扩展依赖。通过这种方式引入的依赖库，不需要 webpack 处理，编译进文件中，在我们需要，使用它的时候可以通过CMD、AMD、或者 window 全局方式访问

例如，可以通过 CDN 去引入 React `<script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>`

### 2.4 动态 import()
webpack 提供了动态加载的 `import()` 方法，可以实现按需加载我们的代码，并且使用了 promise 式的回调，获取加载的包。在代码中所有被 import() 的模块，都将打成一个单独的包，用于实现页面或组件的按需加载。

### 2.5 动态 polyfill

> 为了浏览器的兼容性，我们常常引入各种 polyfill，但是在构建时静态地引入 polyfill 存在一些问题，比如对于机型和浏览器版本比较新的用户来说，他们完全不需要 polyfill，引入 polyfill 对于这部分用户来说是多余的，从而造成体积变大和性能损失

动态 polyfill 指的是根据不同的浏览器，动态载入需要的 polyfill。 Polyfill.io 通过尝试使用 polyfill 重新创建缺少的功能，可以更轻松地支持不同的浏览器，并且可以大幅度的减少构建体积。

原理：根据你的浏览器 UA 头，判断你是否支持某些特性，从而返回给你一个合适的 polyfill。对于最新的 Chrome 浏览器来说，不需要任何 polyfill，所以返回的内容为空。如在 html 文件中引入 `<script crossorigin="anonymous" src="https://polyfill.io/v3/polyfill.js"></script>`

## 三、HTTP 层面

### 3.1 减少 HTTP 请求数
一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程，而如果文件较小，则真正下载数据的时间占比就越小，将多个小文件合并为一个大文件，从而减少 HTTP 请求次数，能提高此比例 

* 每个请求都是有成本的，DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据复杂的过程。（使用缓存功能）
* 每个请求都需要携带数据，每个请求都需要占用带宽（合并请求，如多个图片合并成一张大图）。
* 浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间。（懒加载，只在必要的时机加载）

### 3.2 启用 gzip 压缩
许多网络服务器可以通过调用第三方模块或使用内置程序将文件压缩为 gzip 格式，然后再发送该压缩文件以供下载。这样可以在下载呈现网站所需的资源时节省一些时间。

> Gzip通常将响应大小减少约 70％

### 3.3 改善服务器响应时间
将服务器响应时间控制在 200ms 以内。有很多潜在因素都可能会延缓服务器响应，例如应用逻辑缓慢、数据库查询缓慢、路由缓慢、框架、库、资源CPU不足或内存不足等。

### 3.4 使用 CDN 加速
可降低网络的拥塞状况、提高请求的响应速度，也能够减少源站的负载压力

### 3.5 合理的 HTTP 缓存策略
尽可能利用缓存，对于文件名中有 hash 值时，设置强缓存，如设置 `cache-control: max-age=2592000` (1个月，或者半年、一年等)

### 3.6 域名分片、域名收敛

域名分片：把页面资源拆分成多个域名进行访问，从而提高页面加载速度。原因在于 Web 浏览器会限制每个域名的并发数量，如 6 个（浏览器有并发限制，是为了防止 DDOS攻击），当并行下载文件超过最大并发数就需要排队等待，如果有多个域名，则每个域名都可以发起 6 个 HTTP 请求，提高并发量。另外，不同的域名也可以防止 cookie 污染。（PS: 主要运用于 PC 端）

域名收敛：将静态资源放在一个域名下不进行发散，主要是为了适应移动端的发展需求，通常 DNS 是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对移动端的用户体验是致命的，因此需要进行域名收敛。（PS: 主要运用于移动端）

### 3.7 使用 HTTP2
* 二进制分帧
* 多路复用
* 首部压缩
* 流量控制
* ...

详细介绍可看下面的**相关链接**部分


## 相关链接
* [content-visibility](https://developer.mozilla.org/en-US/docs/Web/CSS/content-visibility)
* [window.requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)
* [高性能渲染十万条数据(虚拟列表)](https://juejin.cn/post/6844903982742110216)
* [CDN原理简析](https://juejin.cn/post/6844903873518239752)
* [一文读懂 HTTP/2 特性](https://zhuanlan.zhihu.com/p/26559480)
